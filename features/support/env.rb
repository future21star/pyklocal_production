# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.
require 'cucumber/rails'

# Capybara defaults to CSS3 selectors rather than XPath.
# If you'd prefer to use XPath, just uncomment this line and adjust any
# selectors in your step definitions to use the XPath syntax.
# Capybara.default_selector = :xpath

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
class ActiveRecord::Base
  mattr_accessor :shared_connection
  @@shared_connection = nil

  def self.connection
    @@shared_connection || retrieve_connection
  end
end
ActiveRecord::Base.shared_connection = ActiveRecord::Base.connection


# Forces all threads to share the same connection. This works on
# Capybara because it starts the web server in a thread.
# ActiveRecord::Base.shared_connection = ActiveRecord::Base.connection


ActionController::Base.allow_rescue = false
Capybara.default_selector = :css
Capybara.default_driver = :selenium
Capybara.default_max_wait_time = 5

# Remove/comment out the lines below if your app doesn't have a database.
# For some databases (like MongoDB and CouchDB) you may need to use :truncation instead.
begin
  require 'database_cleaner'
  require 'database_cleaner/cucumber'

  DatabaseCleaner.strategy = :transaction
rescue NameError
  raise "You need to add database_cleaner to your Gemfile (in the :test group) if you wish to use it."
end

# You may also want to configure DatabaseCleaner to use different strategies for certain features and scenarios.
# See the DatabaseCleaner documentation for details. Example:
#
#   Before('@no-txn,@selenium,@culerity,@celerity,@javascript') do
#     # { :except => [:widgets] } may not do what you expect here
#     # as Cucumber::Rails::Database.javascript_strategy overrides
#     # this setting.
#     DatabaseCleaner.strategy = :truncation
#   end
#
#   Before('~@no-txn', '~@selenium', '~@culerity', '~@celerity', '~@javascript') do
#     DatabaseCleaner.strategy = :transaction
#   end
#

# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
 Cucumber::Rails::Database.javascript_strategy = :truncation 

Around do |scenario, block|
  DatabaseCleaner.cleaning(&block)
end


Before do

  taxonomies = [
    { :name=>"Categories"},
    { :name=>"Brand"}  
  ]
  taxons = [
    {:id=>1, :name=>"Categories"},
    { name: "Bag",parent_id: 1},
    { name: "Mug", parent_id: 1},
    { name: "Clothing", parent_id: 1}
  ]

  taxonomies.each do |data|
    taxonomy = Spree::Taxonomy.where(name: data[:name]).first_or_create 
    if taxonomy.name == "Categories" 
      taxons.each do |product_taxon|
        taxon = Spree::Taxon.where(name: product_taxon[:name], taxonomy_id: taxonomy.id).first_or_create
        taxon.update_attributes(product_taxon.except(:name))
      end
    end
   end 

  color_option_values = [
    { name: "Red", presentation: "Red"} , 
  ]

  size_option_values = [
    { name: "Small", presentation: "S"},
   ]

  [
    {id: 1, name: "color", presentation: "Color"},
    {id: 2, name: "size", presentation: "Size"}
  ].each do |data|
    option_type = Spree::OptionType.where(name: data[:name]).first_or_create
    option_type.update_attributes(data.except(:name))
  p option_type
    if option_type.name == "color"
      color_option_values.each do |color_data|
        option_value = option_type.option_values.where(name: color_data[:name]).first_or_create
        option_value.update_attributes(color_data.except(:name))
      p option_value
      end
    elsif option_type.name == "size"
      size_option_values.each do |model_data|
        option_value = option_type.option_values.where(name: model_data[:name]).first_or_create
        option_value.update_attributes(model_data.except(:name))
        p option_value
      end
    end        
  end  
    
  [
    {:id=>1, :name=>"user"}, 
    {:id=>2, :name=>"merchant"}, 

  ].each do |data|
    role = Spree::Role.where(name: data[:name]).first_or_create
    role.update_attributes(data.except(:name))
  end

  shipping_category = Spree::ShippingCategory.create(name: "Default") 

end



# In your test_helper.rb

# Forces all threads to share the same connection. This works on
# Capybara because it starts the web server in a thread.

